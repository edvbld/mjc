\documentclass[11pt,oneside,a4paper]{article}
\usepackage{fullpage}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    pdftitle={Project Report in DD2448},
    pdfauthor={Erik Helin},
}

% \code
% command for typesetting source code in line
% #1: The source code to format
\newcommand{\code}[1]{\texttt{#1}}

% \file
% command for typesetting a filename in line
% #1: The name of a file
\newcommand{\file}[1]{\texttt{#1}}

% \folder
% command for typesetting a folder name in line
% #1: The name of the folder
\newcommand{\folder}[1]{\texttt{#1}}

% \command
% command for typesetting a command that is typed in at the command prompt
% #1: The command
\newcommand{\command}[1]{\texttt{#1}}

% \class
% command for typesetting a class name in line
% #1: The name of the class
\newcommand{\class}[1]{\underline{\texttt{#1}}}

\setcounter{tocdepth}{3}

\begin{document}
\title{Project report in DD2448, Compiler Construction}
\author{Erik Helin, \href{mailto:ehelin@kth.se}{ehelin@kth.se}}
\date{\today}
\maketitle

\tableofcontents

\section{Introduction}
This document describes the choice of tools, design decisions and the overall 
structure of the code for a MiniJava compiler.
\section{Implementation}
The compiler was first written using the C programming language, with the help
of the tools Bison and Flex for lexing and parsing. However, due to lack of
time, only the lexer and parser was completed. 

The compiler was then rewritten from scratch, this time using the Java
programming language, and the tools JavaCC for parsing and Jasmin as assembler
for the JVM bytecode.

The following sections will discuss the different parts of the compiler.
Section~\ref{sec:lexing_and_parsing} also contains a comparison of the
different tools used for implementing the parser.

For a more general discussion about the two different languages used for the
implementation, see section~\ref{sec:discussion}.
\subsection{Lexing and parsing}
\label{sec:lexing_and_parsing}
The lexer and parser was first implemented using the tools Flex and Bison, Flex
for the lexer and Bison for the parser. Flex creates a lexer from regular
expressions which tokens can be used together with the parser generated by
Bison. Bison generates a LALR-parser from a grammar in Backus-Nauer Form (BNF). 

The biggest challenge when implementing the LALR parser was to understand
the shift/reduce warnings generated by Bison, as these requires you to
understand the automaton produced by Bison.

The abstract syntax tree was represented by using a struct for each kind of
node. Each struct had an enum as the first member that represented 
the type of the node. To simplify the traversal of the syntax tree, 
function pointers was used for callbacks. An function was then provided that 
checked type of the node and called the corresponding callback with the node
casted to the correct type as parameter.

The second parser was implemented using JavaCC to create a LL-parser. The lexer
was also generated with the help of JavaCC by using regular expression, very
similar to Flex. JavaCC uses Extended Backus-Nauer Form (EBNF) to describe the
grammar. The main advantage of using EBNF over BNF was that a lot of rules
could be simplified. For example, the following specifies zero or more variable
declarations in BNF:
\begin{verbatim}
<variable_declarations> ::= 
    "" | <variable_declaration> <variable_declarations>
\end{verbatim}
In EBNF, this can expressed as 
\begin{verbatim}
variable_declarations = variable_declaration*
\end{verbatim} 
which made the parser much more succinct.

The main challenge when writing the LL-parser using JavaCC was to left-factor
the grammar. However, JavaCC produces a top-down parser and allows you to
pass arguments to rules (functions). 
This made left-factoring the grammar  a lot easier, since now it becomes 
possible to pass an already parsed expression as an argument to a 
rule ''below'' it.

The abstract syntax tree was represented by using a class for each node.
Interfaces was used to represent a generic statement, expression or type.
JavaCC provided the JJTree tool for creating an abstract syntax tree, but this
tool proved to be too inflexible and cumbersome. 

For traversing the abstract syntax tree, the visitor pattern was used. 
One problem with the visitor pattern was to implement several kinds of 
visitors (that is, a visitor returning a different type than any existing one). 
For this to work, a new accept method had to be implemented in each node in 
the abstract syntax tree, returning the new type, which quickly become tedious.

\subsection{Type checking}
The type checking part of the compiler was implemented in two stages. In the
first stage, the symbol table is built. In the second stage, the symbol table
is used to type check the MiniJava program. The symbol table consisted of three
different kinds of tables:
\begin{description}
\item{\emph{Program table}} relates names to their corresponding class table
\item{\emph{Class table}} relates names to fields or their corresponding method
table
\item{\emph{Method table}} relates names to parameters or local variables. It 
also contains the return type of the method.
\end{description}
This data structure turned out to be successful, since when traversing the
abstract syntax tree, the current class and program table can be kept as
instance variables and the algorithm for looking up a type for a variable
becomes:
\begin{enumerate}
\item Check for the name in the current method table
\item Check for the name in the current class table
\item Check for the name if the program table
\end{enumerate}

When the symbol table is being built, the MiniJava programs is also partly type
checked. Specifically, if there already exists a definition for a class, field,
or method (including locals and parameters), the symbol table builder will 
return an error. The symbol table builder was implemented with the help of a 
visitor.

In the second phase, the symbol table checker is given the newly constructed 
symbol table. The symbol table checker will then check the type of each
expression according to the Java specification (adjusted for MiniJava). This
was also implemented with the help of a visitor.

\subsection{Java Virtual Machine bytecode generation}
The Jasmin assembler was used to generate the actual bytecode for the Java
Virtual Machine (JVM). Therefore, instead of generating bytecode for the JVM,
Jasmin assembly was generated. The Jasmin assembly was generated with the help
of the abstract syntax tree and the symbol table. 

The Jasmin assembly generator was implemented as a visitor for the abstract
syntax tree. The biggest challenge in the implementation was how to deal with
boolean expressions. A boolean expression can either be used as condition for
jumping to a label or assigning a variable. In the first case, a jump
instruction to a label should be omitted, and in the second, an instruction for
pushing the result onto the stack.

Appel solves this in the MiniJava compiler book by using the interface
\code{Exp}. The \code{Exp} class then exposes three methods for converting
expressions according to their uses. 
I did not choose to implement it this way, instead I used instance variables
for keeping track of the state of the generator. Afterwards, when comparing this
solution to Apples, Apples is the better one, since it is easy to forget to
read and update the instance variables controlling the state. Apples solution
separates these concerns much more, which leads to simpler code.

This pattern could also be noticed when dealing with boolean expressions and
the not (!) operator. There is no bytecode instruction for the JVM to negate a
value on the stack, hence this has to be omitted. A simple extension to Appels
solution would be to require every class implementing the \code{Exp}
interface to also provide the method \code{negate}. This way, omitting the
not operation and how it is implemented would be separated.

Another problem that occurred was when variables, classes or methods had the
same names as a Jasmin assembly instruction. The Jasmin parser would then
raise an error due to a reserved word being used as a class, variable or 
method name. The solution to this specific problem was to escape all class, 
variable and method names by using '.

\section{Architecture of the code}
The following sections will briefly describe each package in the compiler and
how to build the compiler. For each package, the most central classes are
described

The source code for the compiler is available at 
\href{http://www.github.com/helino/mjc}{http://www.github.com/helino/mjc}.

\subsection{Building the compiler}
The compiler is built using the \textbf{ant} build system, which can be 
obtained from \href{http://ant.apache.org}{http://ant.apache.org}. 
To build the compiler, run \command{ant} from the command line. 
The file \file{mjc.jar} will then be available in the
\folder{mjc/dist} folder, and the compiler is started with the command 
\command{java -jar mjc.jar}.

\subsection{\class{se.helino.mjc.Main.java}} \hfill \\
This is the main class of the program. It is responsible for invoking each part
of the compiler and passing the results on to the next part. \file{Main.java} 
also handles all the errors generated by the compiler and prints out error
messages to the user.
\begin{description}
    \item{\code{public static void main(String[] args)}} \hfill \\
        The main method and entry point of the compiler. Command-line arguments
        are available in the \code{args} array.
\end{description}

\subsection{Packages}

\subsubsection{\code{se.helino.mjc.parser}}
The \code{parser} package contains the actual parser, all classes for the 
abstract syntax tree as well as some visitors for traversing the abstract 
syntax tree.

\paragraph{\class{MJParser.jj}} \hfill \\
This is the parser description that is compiled with the help of JavaCC. The
lexer is written at the beginning of the file.
\begin{description}
    \item{\code{public MJParser(InputStream stream)}} \hfill \\
        The constructor for the parser. The parameter is an input stream to the
        MiniJava program.

    \item{\code{public MJProgram ProgramProd()}} \hfill \\
        The main production for parsing a MiniJava program. Returns a
        \code{MJProgram}
        object representing the root node in the abstract syntax tree.
\end{description}

\paragraph{\class{Acceptable.java}} \hfill \\
This is the interface that all abstract syntax tree nodes has to implement in
order to be visitable by a visitor not returning anything.
\begin{description}
    \item{\code{public void accept(Visitor v)}} \hfill \\
        The method for accepting a visitor. The implementation of this method 
        \emph{must} call the
        \code{visit} method on the visitor \code{v} to dispatch back to the
        visitor. 
\end{description}


\paragraph{\class{Visitor.java}} \hfill \\
This is the interface that all visitors that don't require any return type
must implement to be able to visit all the nodes in the abstract syntax tree.
\begin{description}
    \item{\code{public void visit(MJ* v)}} \hfill \\
        Represents the action for the corresponding the abstract
        syntax tree node, and must be implemented for all different types of 
        nodes.  \code{MJ*} means any node, for example \code{MJClass} or
        \code{MJAssign}.
\end{description}

\paragraph{\class{MJ*.java}} \hfill \\
These are all the nodes in the MiniJava abstract syntax tree.

\subsubsection{\code{se.helino.mjc.symbol}}
The \code{symbol} package contains the all classes concerning the type
checking of MiniJava.
\paragraph{\class{SymbolTableBuilder.java}} \hfill \\
This class is responsible for building the actual symbol table data structure.
It also checks if names are declared multiple times in the program.
\begin{description}
    \item{\code{public ProgramTable build(MJProgram program) throws
                  MJTypeException}} \hfill \\
        Builds the symbol table (represented by the class
        \code{ProgramTable}) from an abstract syntax tree (represented by the 
        root node \code{MJProgram}). If any errors are found,
        \code{MJTypeException} is raised.
\end{description}

\paragraph{\class{SymbolTableChecker.java}} \hfill \\
This class type checks a MiniJava program, given a symbol table.
\begin{description}
    \item{\code{public void check(MJProgram program) throws MJTypeException}}
    \hfill \\
        Checks the MiniJava program represent by the abstract
        syntax tree with root node \code{MJProgram}. If any errors are found,
        \code{MJTypeException} is raised.
\end{description}

\subsubsection{\texttt{se.helino.mjc.backends.jvm}}
The \code{backends} package contains all the different back ends available
(currently just the JVM back end). Therefore, the classes listed below are all
in the \code{jvm} package.

\paragraph{\class{JasminFormatter.java}} \hfill \\
Generates Jasmin assembly from an abstract syntax tree and a program table that
has been enhanced with records and stack-depth information. For more details
about the enhanced program table, see~\ref{par:JVMProgramBuilder}
\begin{description}
    \item{\code{public ArrayList<String> generate(MJProgram p)}} \hfill \\
        Generates Jasmin assembly from an abstract syntax tree represented by
        the root node \code{MJProgram}. The Jasmin assembly will be written to
        files, one for each class, and the returned \code{ArrayList} contains
        all these filenames.
\end{description}

\paragraph{\class{JVMProgramBuilder.java}} \hfill \\
Takes a \code{ProgramTable} object and adds additional information, such as the
maximum stack depth for each method, records for each class, frames for each
method and accesses for each variable.
\label{par:JVMProgramBuilder}
\begin{description}
    \item{\code{JVMProgramBuilder(ProgramTable symbolTable)}} \hfill \\
        Takes a symbol table as parameter and creates a new
        \code{JVMProgramBuilder}. The given symbol table (\code{symbolTable})
        will be enhanced with additional information.
    \item{\code{public int visit(MJProgram p)}} \hfill \\
        Adds additional information to the symbol table passed as argument to
        the constructor. The MiniJava abstract syntax tree represented by
        \code{p} is needed to calculate the maximum stack depth for each method
        in the MiniJava program.
\end{description}

\section{Discussion}
\label{sec:discussion}
The main reason for aborting C as the implementation language of the compiler
and move to Java was due to lack of time. Implementing the compiler in C took 
an order of magnitude more time than implementing it in Java. This due to a 
couple of reasons:
\begin{itemize}
\item
    My knowledge of C was rudimentary, which means that I had to learn a lot of
    C at the same time as I implemented the compiler.
\item
    Managing the memory to avoid unnecessary memory leaks took a great deal of
    time. Even though I used tools such as Valgrind to find memory leaks,
    sealing them required a lot of effort.
\item
    The lack of data structures meant that I had to reimplement data structures
    such as a string and a list. This was not hard work, but it still
    took time, and that time was better spent at implementing the actual 
    compiler. 
\end{itemize}
I don't regret trying to use C as the implementation language, as I learned a
lot about how C is used in larger applications. I also learned the effect of
choosing the right language for the task. Note that this doesn't mean that Java 
is the best programming language for writing a compiler, 
only that in my case, it was superior to C.

\appendix
\section{Feedback}
\end{document}
