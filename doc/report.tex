\documentclass[11pt,oneside,a4paper]{article}
\usepackage{fullpage}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    pdftitle={Project Report in DD2448},
    pdfauthor={Erik Helin},
}

\begin{document}
\title{Project report in DD2448, Compiler Construction}
\author{Erik Helin, \href{mailto:ehelin@kth.se}{ehelin@kth.se}}
\date{\today}
\maketitle

\tableofcontents

\section{Introduction}
This document describes the choice of tools, design decisions and the overall 
structure of the code for a MiniJava compiler.
\section{Implementation}
The compiler was first written using the C programming language, with the help
of the tools Bison and Flex for lexing and parsing. However, due to lack of
time, only the lexer and parser was completed. 

I decided to rewrite the compiler from scratch, this time using the Java
programming language, and the tools JavaCC for parsing and Jasmin as assembler
for the JVM bytecode.

The following sections will discuss the different parts of the compiler.
Section \ref{sec:lexing_and_parsing} also contains a comparison of the
different tools used for implementing the parser.

For a general discussion about the two different languages used for the
implementation, see section \ref{sec:discussion}.
\subsection{Lexing and parsing}
\label{sec:lexing_and_parsing}
The lexer and parser was first implemented using the tools Flex and Bison, Flex
for the lexer and Bison for the parser. Flex creates a lexer from regular
expressions which tokens can be used together with the parser generated by
Bison. Bison generates a LALR-parser from a grammar in Backus-Nauer Form (BNF). 

The biggest challenge when implementing the LALR parser was to understand
the shift/reduce warnings generated by Bison, as these requires you to
understand the automaton produced by Bison.

The abstract syntax tree was represented by using a struct for each kind of
node. Each node struct has an enum as their first member that represented 
the type of the node. To simplify the traversal of the syntax tree, 
function pointers was used for callbacks. An function was then provided that 
checked type of the node and called the corresponding callback with the node
casted to the correct type as parameter.

The second parser was implemented using JavaCC to create a LL-parser. The lexer
could also be generated with the help of JavaCC by using regular expression
similar to Flex. JavaCC uses Extended Backus-Nauer Form (EBNF) to describe the
grammar. The main advantage of using EBNF over BNF was that a lot of rules
could be simplified. For example, the following specifies zero or more variable
declaration in BNF:
\begin{verbatim}
<variable_declarations> ::= "" | <variable_declaration> <variable_declarations>
\end{verbatim}
In EBNF, this can expressed as 
\verb|variable_declarations = variable_declaration*| which made the parser much 
more succinct.

The main challenge when writing the LL-parser using JavaCC was to left-factor
the grammar. However, JavaCC produces a top-down parser and allows you to
pass arguments to rules. This made left-factoring the grammar  a lot easier, 
since now it becomes possible to pass an already parsed expression as an 
argument to a rule ''below'' it.

The abstract syntax tree was represented by using a class for each node.
Interfaces was used to represent a generic statement, expression or type.
JavaCC provided the JJTree tool for creating an abstract syntax tree, but this
tool proved to be too inflexible for my needs. For traversing the abstract
syntax tree, the visitor pattern was used. One problem with the visitor pattern
was to implements several kinds of visitors (that is, a visitor returning a
different type than any existing one). For this to work, a new accept method
had to be implemented in each node in the abstract syntax tree, returning the
new type.

\subsection{Type checking}
The type checking part of the compiler was implemented in two stages. In the
first stage, the symbol table is built. In the second stage, the symbol table
is used to type check the MiniJava program. The symbol table consisted of three
different kinds of tables:
\begin{description}
\item{\emph{Program table}} relates names to their corresponding class table
\item{\emph{Class table}} relates names to fields or their corresponding method
table
\item{\emph{Method table}} relates names to parameters or local variables. Also
contains the return type of the method.
\end{description}
This data structure turned out to be successful, since when traversing the
abstract syntax tree, the current class and program table can be kept as
instance variables and the algorithm for looking up a type for a variable
becomes:
\begin{enumerate}
\item Check for the name in the current method table
\item Check for the name in the current class table
\item Check for the name if the program table
\end{enumerate}

When the symbol table is being built, the MiniJava programs is also partly type
checked. Specifically, if there already exists a definition for a class, field,
method (including locals and parameters), the symbol table builder will return
an error. The symbol table builder is implemented with the help of a visitor.

In the second phase, the symbol table checker is given the newly constructed 
symbol table. The symbol table checker will then check the type of each
expression according to the Java specification (adjusted for MiniJava). This is
also implemented with the help of a visitor.

\subsection{Java Virtual Machine bytecode generation}
The Jasmin assembler was used to generate the actual bytecode for the Java
Virtual Machine (JVM). So instead of generating bytecode for the JVM,
Jasmin assembly was generated. The Jasmin assembly was generated with the help
of the abstract syntax tree and the symbol table. 

The Jasmin assembly generator was implemented as a visitor for the abstract
syntax tree. The biggest challenge in the implementation was how to deal with
boolean expressions. An boolean expression can either be used as condition for
jumping to a label, or assigning a variable. In the first case, a jump
instruction a label should be omitted, and in the second, a instruction for
pushing the result onto the stack.

Appel solves this in the MiniJava compiler book by using the interface
\texttt{Exp}. The \texttt{Exp} class then exposes three methods for converting
expressions according to their uses. 
I did not choose to implement it this way, instead I used instance variables
for keeping track of the state of the generator. Afterwards, when comparing my
solution to Apples, Apples is the better one, because it was easy to forget to
read and update the instance variables controlling the state. Apples solution
separates the concerns much more, which leads to cleaner code.

This pattern could also be noticed when dealing with boolean expressions and
the not (!) operator. There is no bytecode instruction for the JVM to negate a
value on the stack, hence this has to be omitted. A simple extension to Appels
solution would be to require every class implementing the \texttt{Exp}
interface to also provide the method \texttt{negate}. This way, omitting the
not operation and how it is implemented would be separated.

Another problem that occurred was when variables, classes or methods had the
same names as an Jasmin assembly instruction. The Jasmin parser would then
raise due to a reserved word being used as a class, variable or method name. The
solution to this specific problem was to escape all class, variable and method
names.
\section{Architecture of the code}
The following sections will briefly describe each package in the compiler. The
code is separated into multiple packages, with the class \texttt{Main.java}
tying them all together.
\subsection{\texttt{se.helino.mjc.parser}}
\subsection{\texttt{se.helino.mjc.symbol}}
\subsection{\texttt{se.helino.mjc.backends.jvm}}
\section{Discussion}
\label{sec:discussion}
\appendix
\section{Feedback}
\end{document}
